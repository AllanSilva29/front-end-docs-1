---
title: 'Objetos: Sintaxes Modernas (Shorthand)'
description: 'Aprenda a usar sintaxes curtas (shorthand) do ES6 para criar e definir propriedades e m√©todos em objetos JavaScript de forma mais concisa.'
---

import { Aside, Card, CardGrid, Tabs, TabItem } from '@astrojs/starlight/components';

O ES6 introduziu v√°rias melhorias de "qualidade de vida" para a cria√ß√£o e manipula√ß√£o de objetos. Essas sintaxes curtas (ou "shorthands") ajudam a reduzir a verbosidade e a tornar o c√≥digo mais limpo.

## Property Shorthand (Atalho de Propriedade)

Este √© o shorthand mais comum. Se voc√™ tem uma vari√°vel cujo nome √© o mesmo que a chave da propriedade do objeto que voc√™ quer criar, voc√™ pode omitir a parte do valor.

<Tabs>
<TabItem label="O Jeito Antigo">
```javascript
const name = "Ana";
const age = 30;

const user = {
  name: name,
  age: age
};

console.log(user); // { name: "Ana", age: 30 }
```
</TabItem>
<TabItem label="Com Property Shorthand">
```javascript
const name = "Ana";
const age = 30;

// Se a chave e a vari√°vel t√™m o mesmo nome, basta colocar a vari√°vel.
const user = {
  name,
  age
};

console.log(user); // { name: "Ana", age: 30 }
```
</TabItem>
</Tabs>

Isso √© extremamente √∫til ao construir objetos a partir de vari√°veis existentes, uma tarefa comum em qualquer aplica√ß√£o.

## Method Shorthand (Atalho de M√©todo)

Da mesma forma, ao definir uma fun√ß√£o como uma propriedade de um objeto (um m√©todo), voc√™ pode omitir a palavra-chave `function` e os dois-pontos.

<Tabs>
<TabItem label="O Jeito Antigo">
```javascript
const calculator = {
  add: function(a, b) {
    return a + b;
  },
  subtract: function(a, b) {
    return a - b;
  }
};
```
</TabItem>
<TabItem label="Com Method Shorthand">
```javascript
const calculator = {
  add(a, b) {
    return a + b;
  },
  subtract(a, b) {
    return a - b;
  }
};

console.log(calculator.add(5, 3)); // 8
```
</TabItem>
</Tabs>

## Computed Property Names (Nomes de Propriedade Computados)

Isso permite que voc√™ use uma express√£o (como uma vari√°vel) para definir o nome de uma chave de propriedade dinamicamente, diretamente na cria√ß√£o do objeto.

<Tabs>
<TabItem label="O Jeito Antigo">
```javascript
const keyName = "favoriteFood";
const person = {
  name: "Carlos"
};

// A propriedade precisa ser adicionada depois da cria√ß√£o do objeto.
person[keyName] = "Pizza";

console.log(person); // { name: "Carlos", favoriteFood: "Pizza" }
```
</TabItem>
<TabItem label="Com Nomes Computados">
```javascript
const keyName = "favoriteFood";

const person = {
  name: "Carlos",
  // A express√£o dentro dos colchetes [] √© avaliada,
  // e seu resultado se torna o nome da chave.
  [keyName]: "Pizza"
};

console.log(person); // { name: "Carlos", favoriteFood: "Pizza" }
```
</TabItem>
</Tabs>

<Card title="ü§ù Juntando Tudo">
Podemos combinar todas essas sintaxes para criar objetos de forma muito expressiva.

```javascript
function createUser(name, age) {
  const dynamicKey = `${name}_status`;

  return {
    name, // Property shorthand
    age,  // Property shorthand
    
    [dynamicKey]: 'active', // Computed property name

    greet() { // Method shorthand
      return `Ol√°, meu nome √© ${this.name}!`;
    }
  };
}

const newUser = createUser('Davi', 25);
console.log(newUser);
/*
{
  name: 'Davi',
  age: 25,
  Davi_status: 'active',
  greet: [Function: greet]
}
*/
console.log(newUser.greet()); // Ol√°, meu nome √© Davi!
```
</Card>

Essas sintaxes podem parecer pequenas, mas seu uso consistente em uma base de c√≥digo resulta em um software significativamente mais leg√≠vel e f√°cil de manter.

---

At√© agora, todo o nosso c√≥digo foi s√≠ncrono, executando uma instru√ß√£o ap√≥s a outra. Mas como lidamos com opera√ß√µes que levam tempo, como buscar dados de um servidor? A seguir, vamos explorar o mundo ass√≠ncrono com **Promises e async/await**.
