---
title: Tipos Básicos e Estruturais
description: Aprenda sobre os tipos fundamentais do TypeScript, como `string`, `number`, `array`, `object`, e a diferença crucial entre `type` e `interface`.
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

Todo o poder do TypeScript começa com sua capacidade de entender os "tipos" de dados. Nesta página, vamos cobrir os blocos de construção essenciais que você usará para descrever suas variáveis, props e estados.

## Tipos Primitivos

Estes são os tipos de dados mais básicos, herdados diretamente do JavaScript.

-   **`string`**: Para textos. Ex: `let name: string = "React";`
-   **`number`**: Para números, sejam inteiros ou de ponto flutuante. Ex: `let version: number = 18;`
-   **`boolean`**: Para valores verdadeiros ou falsos. Ex: `let isAwesome: boolean = true;`
-   **`null`**: Para a ausência intencional de um valor.
-   **`undefined`**: Para variáveis que foram declaradas mas não inicializadas.

## Tipos Especiais

O TypeScript adiciona alguns tipos especiais para lidar com cenários específicos.

-   **`any`**: Permite qualquer tipo. Essencialmente, desliga a verificação de tipos do TypeScript para uma variável.

    <Aside type="danger" title="Cuidado com o 'any'">
    O `any` é uma porta de escape, mas deve ser evitado sempre que possível. Usá-lo anula os benefícios de segurança do TypeScript e pode esconder bugs. Use-o apenas como último recurso ou durante a migração de um código JavaScript.
    </Aside>

-   **`unknown`**: Uma alternativa mais segura ao `any`. Você pode atribuir qualquer valor a uma variável do tipo `unknown`, mas não pode usá-la sem antes fazer uma verificação de tipo (narrowing).

    ```ts
    let value: unknown = "Olá, mundo!";

    // Erro: 'value' is of type 'unknown'.
    // console.log(value.toUpperCase());

    // Correto: Verificamos o tipo antes de usar.
    if (typeof value === 'string') {
      console.log(value.toUpperCase()); // Agora funciona!
    }
    ```

-   **`void`**: Usado principalmente para indicar que uma função não retorna nenhum valor. Veremos mais sobre isso ao tipar funções.

## Estruturas de Dados

Para dados mais complexos, como arrays e objetos, o TypeScript oferece uma sintaxe clara.

### Arrays

Você pode tipar um array de duas maneiras:

```ts
// Sintaxe preferida e mais comum:
const versions: number[] = [16, 17, 18];
const names: string[] = ["React", "Vue", "Svelte"];

// Sintaxe genérica (menos comum):
const tools: Array<string> = ["Vite", "Webpack"];
```

### Objetos

Para objetos, você descreve sua "forma" (shape), listando suas propriedades e os tipos correspondentes.

```ts
let myComponent: {
  name: string;
  version: number;
  isReleased: boolean;
};

myComponent = {
  name: "React",
  version: 18,
  isReleased: true,
};
```

Definir a forma de um objeto diretamente na anotação de tipo pode ser verboso. Para estruturas reutilizáveis, como props de componentes, usamos `type` ou `interface`.

## `type` vs. `interface`

`type` e `interface` são duas maneiras de nomear um tipo de objeto. Ambas são muito parecidas, mas têm diferenças sutis.

<Tabs>
  <TabItem label="Usando `type`">
    ```ts
    type ComponentProps = {
      title: string;
      disabled?: boolean; // '?' torna a propriedade opcional
    };

    const Button = (props: ComponentProps) => {
      // ...
    };
    ```
  </TabItem>
  <TabItem label="Usando `interface`">
    ```ts
    interface ComponentProps {
      title: string;
      disabled?: boolean; // '?' torna a propriedade opcional
    };

    const Button = (props: ComponentProps) => {
      // ...
    };
    ```
  </TabItem>
</Tabs>

**Principais diferenças:**

1.  **Extensão:** Interfaces podem ser "reabertas" e ter novas propriedades adicionadas (declaration merging), o que é útil para estender tipos em bibliotecas. `type` não pode ser reaberto, mas pode ser combinado usando uniões (`|`) e interseções (`&`).
2.  **Unions e Intersections:** A sintaxe para criar tipos complexos com `type` é geralmente mais limpa e direta.

<Aside type="tip" title="Qual usar em projetos React?">
Uma convenção popular e recomendada é:
*   Use **`type`** para definir props e estados dentro da sua aplicação. A sintaxe é mais consistente com outras funcionalidades do TS como `union types`.
*   Use **`interface`** se você estiver criando uma biblioteca pública ou precisar da capacidade de "declaration merging".

Para o nosso guia, focaremos principalmente no uso de `type` por ser mais comum no desenvolvimento de aplicações React modernas.
</Aside>

---

## Acessando Propriedades com Segurança: O Opcional (`?`) e o Perigoso (`!`)

Um dos erros mais famosos do JavaScript é o `TypeError: Cannot read properties of undefined (reading 'propriedade')`. O TypeScript nos ajuda a evitar isso em **tempo de compilação**, mas o erro ainda pode acontecer em **tempo de execução**.

Vamos entender por quê e como lidar com isso.

Imagine um tipo `User` que pode ser `null`:
```ts
type User = {
  name: string;
  profile?: { // O perfil é opcional
    avatarUrl: string;
  }
}

let currentUser: User | null = null; // O usuário pode não estar logado
```

Se tentarmos acessar `currentUser.name`, o TypeScript nos avisará, pois `currentUser` pode ser `null`. Mas e se acessarmos `currentUser.profile.avatarUrl`? Temos dois pontos de falha!

### 1. Optional Chaining (`?.`) - A Abordagem Segura

O operador de encadeamento opcional (`?.`) verifica se o valor à sua esquerda é `null` ou `undefined` **antes** de tentar acessar a propriedade à direita. Se for, a expressão inteira para e retorna `undefined`.

```ts
// Se `currentUser` for null, retorna `undefined`.
// Se `currentUser.profile` for undefined, retorna `undefined`.
// Só tenta acessar `avatarUrl` se ambos existirem.
const avatar = currentUser?.profile?.avatarUrl;

// `avatar` terá o tipo `string | undefined`
```
O `?.` é seu melhor amigo para navegar com segurança por objetos que podem ter partes faltando. **Sempre prefira esta abordagem.**

### 2. Non-null Assertion (`!`) - A Abordagem Perigosa

O operador de asserção não-nula (`!`) é uma forma de **dizer ao compilador do TypeScript para calar a boca**. Você o usa quando tem 100% de certeza de que um valor não é `null` ou `undefined`, mesmo que o tipo diga que ele poderia ser.

```ts
function processUser(user: User | null) {
  if (user === null) {
    throw new Error("Usuário não pode ser nulo!");
  }

  // Neste ponto, NÓS sabemos que `user` não é nulo.
  // Podemos usar `!` para dizer isso ao TypeScript.
  const name = user!.name;
}
```

<Aside type="danger" title="Use `!` com extrema cautela!">
O `!` **NÃO** faz nenhuma verificação em tempo de execução. Ele é uma instrução apenas para o compilador. Se você estiver errado e o valor for `null` ou `undefined`, **sua aplicação vai quebrar** com o mesmo `TypeError` de sempre.

Use-o apenas quando uma verificação explícita (como `if (user)`) já foi feita ou quando você tem certeza absoluta por outras razões lógicas. Abusar do `!` é um anti-padrão que anula a segurança do TypeScript.
</Aside>