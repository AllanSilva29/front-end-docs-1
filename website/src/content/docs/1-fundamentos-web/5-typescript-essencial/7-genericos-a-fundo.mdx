---
title: Gen√©ricos (Generics) a Fundo
description: Um mergulho profundo em gen√©ricos (generics), a ferramenta mais poderosa do TypeScript para criar componentes e fun√ß√µes reutiliz√°veis e com seguran√ßa de tipos.
---

import { Card, CardGrid, Aside } from '@astrojs/starlight/components';

Gen√©ricos, ou *Generics*, s√£o um dos recursos mais poderosos do TypeScript. Eles permitem que voc√™ escreva c√≥digo que funciona com uma variedade de tipos, em vez de um √∫nico tipo. Pense neles como "vari√°veis de tipo", que permitem criar componentes e fun√ß√µes que s√£o ao mesmo tempo flex√≠veis e seguros.

### O Problema: Fun√ß√µes Repetitivas

Imagine que voc√™ precisa de uma fun√ß√£o que pega o √∫ltimo item de um array. Sem gen√©ricos, voc√™ teria que escrever uma fun√ß√£o para cada tipo de array.

```ts
// Uma fun√ß√£o para um array de n√∫meros
function getLastNumberItem(items: number[]): number | undefined {
  return items[items.length - 1];
}

// Uma fun√ß√£o para um array de strings
function getLastStringItem(items: string[]): string | undefined {
  return items[items.length - 1];
}

// E se tiv√©ssemos um array de objetos? Ter√≠amos que criar outra...
```
O c√≥digo √© id√™ntico, apenas os tipos mudam. Isso n√£o √© eficiente.

### A Solu√ß√£o: A Fun√ß√£o Gen√©rica

Com gen√©ricos, podemos criar uma √∫nica fun√ß√£o que funciona para **qualquer** tipo de array.

```ts
function getLastItem<T>(items: T[]): T | undefined {
  return items[items.length - 1];
}

// Uso:
const numbers = [1, 2, 3];
const lastNumber = getLastItem(numbers); // `lastNumber` √© inferido como `number`

const strings = ["a", "b", "c"];
const lastString = getLastItem(strings); // `lastString` √© inferido como `string`
```

<Aside type="note" title="Anatomia da Fun√ß√£o Gen√©rica">
Vamos quebrar `function getLastItem<T>(items: T[]): T | undefined`.

1.  **`<T>`**: Esta √© a declara√ß√£o do **par√¢metro de tipo gen√©rico**. `T` √© um placeholder (um "apelido") para um tipo que ser√° definido quando a fun√ß√£o for chamada. Voc√™ pode usar qualquer letra, mas `T` (de *Type*) √© a conven√ß√£o.

2.  **`(items: T[])`**: Aqui, usamos `T` para tipar um argumento. Estamos dizendo: "o par√¢metro `items` ser√° um array de... seja l√° o que `T` for". Se passarmos um `number[]`, `T` se torna `number`. Se passarmos um `string[]`, `T` se torna `string`.

3.  **`: T | undefined`**: Aqui, usamos `T` para tipar o valor de retorno. Estamos dizendo: "esta fun√ß√£o retornar√° um valor do mesmo tipo `T` que foi passado, ou `undefined` se o array estiver vazio".

O TypeScript conecta tudo: o tipo do array de entrada determina o tipo do item de sa√≠da.
</Aside>

Outro exemplo:

```ts
function identidade<T>(valor: T): T {
  return valor;
}

// Aqui, estamos passando explicitamente o tipo como string
const nome = identidade<string>('Allan');
```

Isso √© a **mesma l√≥gica** de:

```ts
const [usuario, setUsuario] = useState<User | null>(null);
```

Aqui, o `useState` √© uma fun√ß√£o gen√©rica, e estamos dizendo: "o tipo do estado pode ser `User` ou `null`".

---

### Aplicando Gen√©ricos em Componentes React

Este conceito √© extremamente √∫til para criar componentes reutiliz√°veis em React. O exemplo cl√°ssico √© um componente de lista que pode renderizar qualquer tipo de dado.

```tsx
import type { ReactNode } from 'react';

// 1. Definimos as props usando um tipo gen√©rico T
interface GenericListProps<T> {
  items: T[];
  renderItem: (item: T) => ReactNode;
}

// 2. Declaramos que o componente √© gen√©rico
// A v√≠rgula em `<T,>` √© necess√°ria na sintaxe TSX para evitar ambiguidade com tags HTML
const GenericList = <T,>({ items, renderItem }: GenericListProps<T>) => {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{renderItem(item)}</li>
      ))}
    </ul>
  );
};
```

<Aside type="note" title="Anatomia do Componente Gen√©rico">
1.  **`interface GenericListProps<T>`**: Assim como na fun√ß√£o, declaramos um tipo gen√©rico `T` para a nossa interface de props.

2.  **`items: T[]`**: A prop `items` √© um array do tipo gen√©rico `T`.

3.  **`renderItem: (item: T) => ReactNode`**: A prop `renderItem` √© uma fun√ß√£o. Seu primeiro argumento, `item`, √© do tipo `T`, garantindo que ele corresponda aos itens do array.

4.  **`const GenericList = <T,>`**: Declaramos que o pr√≥prio componente `GenericList` √© gen√©rico. O TypeScript agora sabe que quando usarmos `<GenericList ... />`, ele precisa resolver o que √© `T`.
</Aside>

**Uso do componente:**
```tsx
const users = [
  { id: 1, name: 'Ada Lovelace' },
  { id: 2, name: 'Grace Hopper' },
];

// O TypeScript infere que T √© `{ id: number, name: string }`
// e garante que `user.name` existe dentro de `renderItem`.
<GenericList
  items={users}
  renderItem={(user) => <span>{user.name}</span>}
/>
```

### Aprimorando com Constraints (`extends`)

E se nosso componente precisar que o tipo `T` tenha uma certa "forma"? Por exemplo, para usar uma propriedade `id` como `key` na nossa lista.

Podemos adicionar uma **constraint** (restri√ß√£o) ao nosso tipo gen√©rico usando a palavra-chave `extends`.

```tsx
// ...

// T n√£o √© mais qualquer coisa. Agora, T DEVE TER uma propriedade `id` do tipo string ou number.
interface GenericListProps<T extends { id: string | number }> {
  items: T[];
  renderItem: (item: T) => ReactNode;
}

const GenericListWithKey = <T extends { id: string | number },>({ items, renderItem }: GenericListProps<T>) => {
  return (
    <ul>
      {/* Agora √© seguro usar item.id, pois a constraint garante que ele existe! */}
      {items.map((item) => (
        <li key={item.id}>{renderItem(item)}</li>
      ))}
    </ul>
  );
};
```
Com `extends { id: string | number }`, estamos dizendo ao TypeScript: "`T` pode ser qualquer tipo, **desde que** ele tenha uma propriedade `id`". Isso nos d√° o melhor dos dois mundos: flexibilidade e seguran√ßa.

<Aside type="tip" title="Onde mais usamos fun√ß√µes gen√©ricas? üß©">

* **Fun√ß√µes utilit√°rias**: como `Array.map`, `Promise`, `fetch`, `filter`, etc.
* **Classes gen√©ricas**: ex: uma `Queue<T>` para estrutura de dados.
* **Componentes gen√©ricos**: em bibliotecas como React, Angular, Vue com TS, etc.
* **APIs com tipos din√¢micos**: como fun√ß√µes que recebem dados de um endpoint e precisam retornar um tipo baseado no par√¢metro.

Exemplo com `fetch` tipado:

```ts
async function buscarDados<T>(url: string): Promise<T> {
  const res = await fetch(url);
  return await res.json();
}

interface Produto {
  id: number;
  nome: string;
}

const produto = await buscarDados<Produto>('/api/produto/1');
```
</Aside>

---

Dominar gen√©ricos √© um salto de qualidade no seu desenvolvimento com TypeScript. Permite criar abstra√ß√µes poderosas e seguras, resultando em um c√≥digo mais limpo, reutiliz√°vel e profissional.