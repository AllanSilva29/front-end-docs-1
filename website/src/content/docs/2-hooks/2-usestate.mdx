---
title: 'useState: Adicionando Estado'
description: 'Aprenda a usar o Hook useState para adicionar estado local a componentes de fun√ß√£o, tornando-os din√¢micos e interativos.'
---

import { Aside, Card, CardGrid, Tabs, TabItem } from '@astrojs/starlight/components';

O `useState` √© o primeiro e mais fundamental Hook que voc√™ aprender√°. Sua √∫nica finalidade √© permitir que componentes de fun√ß√£o "lembrem" de informa√ß√µes entre as renderiza√ß√µes. Em outras palavras, ele **adiciona estado** a um componente.

Sempre que voc√™ precisar de uma vari√°vel que, ao ser alterada, deve fazer com que o componente se atualize na tela, voc√™ precisa do `useState`.

## A Sintaxe do `useState`

Para usar o `useState`, voc√™ o chama no n√≠vel superior do seu componente. Ele retorna um array com exatamente dois elementos, que geralmente desestruturamos imediatamente.

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  // ...
}
```

Vamos quebrar essa linha:

<CardGrid>
	<Card title="useState(0) üß¨">
		A chamada da fun√ß√£o `useState` com `0` como argumento. Este argumento √© o **estado inicial** ‚Äî o valor que a vari√°vel de estado ter√° na primeira renderiza√ß√£o.
	</Card>
	<Card title="count üî¢">
		O primeiro elemento do array retornado. √â a sua **vari√°vel de estado**. Ela cont√©m o valor atual do estado (`0` na primeira renderiza√ß√£o, `1` ap√≥s o primeiro clique, e assim por diante). Voc√™ a usa para ler o estado.
	</Card>
    <Card title="setCount üéØ">
		O segundo elemento do array. √â a **fun√ß√£o de atualiza√ß√£o**. Voc√™ a chama para mudar o valor de `count` e para "avisar" ao React que ele precisa re-renderizar o componente.
	</Card>
</CardGrid>

<Aside type="tip">
Usar a desestrutura√ß√£o de array `[valor, setValor]` √© uma conven√ß√£o. A vantagem √© que podemos nomear nossas vari√°veis de estado como quisermos, o que √© √∫til quando temos m√∫ltiplos estados em um mesmo componente.
</Aside>

## A Regra de Ouro: Imutabilidade

A regra mais importante ao trabalhar com estado em React √©: **nunca modifique o estado diretamente**. Sempre use a fun√ß√£o de atualiza√ß√£o fornecida pelo `useState`.

O React depende da mudan√ßa de refer√™ncia da vari√°vel de estado para saber que precisa re-renderizar. Se voc√™ mutar o estado diretamente, o React n√£o perceber√° a mudan√ßa e sua UI n√£o ser√° atualizada.

<Tabs>
<TabItem label="‚ùå N√£o fa√ßa isso">
```jsx
// ERRADO! Isso n√£o vai re-renderizar o componente.
function BrokenCounter() {
  let [count, setCount] = useState(0);

  function handleClick() {
    count = count + 1; // MUTA√á√ÉO DIRETA
    console.log(count); // O console mostrar√° o valor atualizado, mas a tela n√£o.
  }

  return <button onClick={handleClick}>Contador Quebrado: {count}</button>;
}
```
</TabItem>
<TabItem label="‚úÖ Fa√ßa isso">
```jsx
// CORRETO! Usa a fun√ß√£o de atualiza√ß√£o.
function WorkingCounter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1); // Avisa ao React para atualizar o estado e re-renderizar.
  }

  return <button onClick={handleClick}>Contador Funcional: {count}</button>;
}
```
</TabItem>
</Tabs>

## Atualizando Estado com Objetos e Arrays

A regra da imutabilidade √© especialmente importante com objetos e arrays. Voc√™ deve sempre criar um **novo** objeto ou array ao atualizar o estado, em vez de modificar o existente. A sintaxe de "spread" (`...`) √© sua melhor amiga aqui.

```jsx
function UserProfile() {
  const [user, setUser] = useState({ name: 'Ana', age: 25 });

  function handleBirthday() {
    // Cria um NOVO objeto, copiando as propriedades antigas
    // e sobrescrevendo a propriedade 'age'.
    setUser({ ...user, age: user.age + 1 });
  }

  return (
    <div>
      <p>{user.name}, {user.age} anos</p>
      <button onClick={handleBirthday}>Fazer Anivers√°rio</button>
    </div>
  );
}
```

## Atualiza√ß√µes a Partir do Estado Anterior

E se voc√™ precisar atualizar o estado com base em seu valor anterior? A abordagem `setCount(count + 1)` geralmente funciona, mas pode falhar em alguns casos espec√≠ficos (como em atualiza√ß√µes muito r√°pidas e em lote).

A forma mais segura √© passar uma **fun√ß√£o** para a sua fun√ß√£o de atualiza√ß√£o. Essa fun√ß√£o receber√° o estado pendente (o valor mais recente) como argumento e deve retornar o novo estado.

```jsx
// Forma segura de incrementar
setCount(prevCount => prevCount + 1);

// Forma segura de adicionar um item a um array
setItems(prevItems => [...prevItems, newItem]);
```

Isso garante que voc√™ est√° sempre trabalhando com o valor mais atualizado do estado, evitando "race conditions".

---

Agora que nossos componentes t√™m "mem√≥ria" e podem mudar, como fazemos para que eles interajam com o mundo exterior ‚Äî como buscar dados de uma API ou manipular o DOM? Para isso, usaremos o Hook de efeitos colaterais: **`useEffect`**.
