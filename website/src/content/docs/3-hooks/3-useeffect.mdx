---
title: 'useEffect: Efeitos Colaterais'
description: 'Domine o Hook useEffect para lidar com efeitos colaterais como busca de dados (fetching), timers e manipula√ß√£o do DOM em seus componentes React.'
---

import { Aside, Card, CardGrid, Tabs, TabItem } from '@astrojs/starlight/components';

Enquanto o `useState` nos d√° mem√≥ria interna, o `useEffect` nos permite conectar nossos componentes ao "mundo exterior". Ele √© o Hook para lidar com **efeitos colaterais** (side effects).

Mas o que √© um efeito colateral? √â qualquer a√ß√£o que afeta algo fora do escopo da renderiza√ß√£o do pr√≥prio componente, como:

-   Buscar dados de uma API (`fetch`).
-   Configurar uma inscri√ß√£o (subscription), como em um servi√ßo de chat.
-   Manipular o DOM diretamente (embora raro, √†s vezes √© necess√°rio).
-   Adicionar e remover `event listeners`.
-   Configurar timers como `setTimeout` ou `setInterval`.

O `useEffect` √© a combina√ß√£o dos m√©todos de ciclo de vida de classe `componentDidMount`, `componentDidUpdate` e `componentWillUnmount` em uma √∫nica API.

## A Anatomia do `useEffect`

O `useEffect` aceita dois argumentos:

1.  Uma **fun√ß√£o de "efeito"**: O c√≥digo que voc√™ quer executar.
2.  Um **array de depend√™ncias** (opcional): A lista de valores que, se mudarem, far√£o com que o efeito seja executado novamente.

```jsx
import { useEffect, useState } from 'react';

function MyComponent() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // 1. A fun√ß√£o de efeito
    document.title = `Voc√™ clicou ${count} vezes`;
  }, [count]); // 2. O array de depend√™ncias
  
  // ...
}
```

## O Array de Depend√™ncias: Controlando a Execu√ß√£o

O segundo argumento √© a parte mais importante para controlar o `useEffect`. Ele dita **quando** o efeito deve ser executado.

<Tabs>
<TabItem label="Executa a cada renderiza√ß√£o">
**Se voc√™ omitir o array**, o efeito ser√° executado ap√≥s a **primeira renderiza√ß√£o** e depois **ap√≥s toda e qualquer re-renderiza√ß√£o**. Isso √© raramente o que voc√™ quer e pode causar la√ßos infinitos se o efeito atualizar o estado.

```jsx
useEffect(() => {
  // Roda sempre que o componente re-renderizar.
  console.log('Componente renderizou');
});
```
</TabItem>
<TabItem label="Executa apenas uma vez">
**Se voc√™ passar um array vazio `[]`**, o efeito ser√° executado **apenas uma vez**, logo ap√≥s o componente ser "montado" (renderizado pela primeira vez). √â o equivalente ao `componentDidMount`.

Ideal para:
-   Buscar dados iniciais de uma API.
-   Configurar listeners ou subscriptions que duram toda a vida do componente.

```jsx
useEffect(() => {
  // Roda apenas na primeira renderiza√ß√£o.
  fetchDataFromApi();
}, []);
```
</TabItem>
<TabItem label="Executa quando um valor muda">
**Se voc√™ passar valores no array `[dep1, dep2]`**, o efeito ser√° executado na primeira renderiza√ß√£o e, depois, ser√° re-executado **somente se um desses valores mudar** entre as renderiza√ß√µes. √â o equivalente ao `componentDidUpdate`.

```jsx
useEffect(() => {
  // Roda na primeira renderiza√ß√£o e sempre que 'userId' mudar.
  fetchUserData(userId);
}, [userId]);
```
</TabItem>
</Tabs>

## A Fun√ß√£o de Limpeza (Cleanup)

E se o seu efeito colateral precisar ser "desfeito"? Por exemplo, se voc√™ adiciona um `event listener`, precisa remov√™-lo quando o componente for desmontado para evitar vazamentos de mem√≥ria (memory leaks).

Para isso, voc√™ pode retornar uma **fun√ß√£o de limpeza** de dentro do seu efeito. O React executar√° essa fun√ß√£o:
1.  Antes do componente ser removido da tela.
2.  Antes de re-executar o efeito na pr√≥xima vez (devido a uma mudan√ßa nas depend√™ncias).

<Card title="Exemplo: Limpando um Event Listener üßº">
```jsx
function MousePosition() {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    // Efeito: Adiciona o listener
    const handleMouseMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };
    window.addEventListener('mousemove', handleMouseMove);
    console.log('Listener adicionado!');

    // Limpeza: Retorna uma fun√ß√£o que remove o listener
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      console.log('Listener removido!');
    };
  }, []); // Array vazio, ent√£o a limpeza s√≥ ocorre quando o componente √© desmontado.

  return <p>Posi√ß√£o do mouse: X: {position.x}, Y: {position.y}</p>;
}
```
</Card>

## Sincroniza√ß√£o, N√£o Ciclo de Vida

<Aside type="tip" title="Mudan√ßa de Mentalidade">
Tente pensar no `useEffect` n√£o como "fa√ßa isso quando o componente montar", mas sim como "**sincronize este componente com um sistema externo**". O array de depend√™ncias diz ao React: "sempre que um desses valores mudar, re-sincronize". A fun√ß√£o de limpeza diz como "des-sincronizar". Essa mentalidade ajuda a usar o Hook de forma mais correta e intuitiva.
</Aside>

---

Com o `useEffect`, podemos interagir com o mundo exterior. Mas como compartilhamos dados entre componentes distantes sem passar `props` por v√°rios n√≠veis? Para isso, usaremos o **`useContext`**.
