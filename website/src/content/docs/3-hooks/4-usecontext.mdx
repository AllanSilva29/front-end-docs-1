---
title: 'useContext: Dados Globais'
description: 'Aprenda a usar o Hook useContext para compartilhar dados entre componentes distantes sem a necessidade de "prop drilling".'
---

import { Aside, Card, CardGrid, Tabs, TabItem } from '@astrojs/starlight/components';

Em uma aplica√ß√£o React, os dados geralmente fluem de cima para baixo, de componentes pais para filhos, atrav√©s de `props`. Mas o que acontece quando um componente profundamente aninhado precisa de um dado que est√° no topo da √°rvore de componentes?

### O Problema: Prop Drilling

Passar `props` manualmente atrav√©s de v√°rios n√≠veis de componentes intermedi√°rios que n√£o precisam desses dados √© uma pr√°tica chamada **"prop drilling"**.



O prop drilling torna o c√≥digo mais verboso, dif√≠cil de manter e acopla componentes que n√£o deveriam ter conhecimento um do outro.

### A Solu√ß√£o: Context API e `useContext`

O React oferece uma solu√ß√£o nativa para esse problema: a **Context API**. Ela permite criar um "t√∫nel" de dados que pode ser acessado por qualquer componente dentro de sua √°rvore, n√£o importa qu√£o profundo ele esteja.

O processo envolve tr√™s passos:

<CardGrid>
	<Card title="1. Criar o Contexto üõ†Ô∏è">
		Usamos a fun√ß√£o `createContext` para criar um objeto de contexto. Podemos fornecer um valor padr√£o, que ser√° usado se um componente tentar consumir o contexto sem um provedor acima dele.
	</Card>
	<Card title="2. Prover o Contexto üì¶">
		Envolvemos uma parte da nossa √°rvore de componentes com o `Context.Provider`. O `Provider` aceita uma `prop` `value`, que s√£o os dados que queremos compartilhar.
	</Card>
    <Card title="3. Consumir o Contexto üçΩÔ∏è">
		Qualquer componente filho dentro do `Provider` pode agora acessar o valor do contexto usando o Hook `useContext`.
	</Card>
</CardGrid>

## Exemplo Pr√°tico: Um Provedor de Tema

Vamos criar um sistema simples de tema (Dark/Light Mode) para ilustrar o conceito.

<Tabs>
<TabItem label="1. theme-context.js">
```jsx
import { createContext } from 'react';

// 1. Criamos o contexto. 'light' √© o valor padr√£o.
export const ThemeContext = createContext('light'); 
```
</TabItem>
<TabItem label="2. App.jsx (Provedor)">
```jsx
import { useState } from 'react';
import { ThemeContext } from './theme-context';
import Toolbar from './Toolbar';

function App() {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    setTheme(currentTheme => (currentTheme === 'light' ? 'dark' : 'light'));
  };

  // 2. Envolvemos os componentes com o Provider, passando o tema atual
  //    e a fun√ß√£o para troc√°-lo como 'value'.
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      <Toolbar />
      <button onClick={toggleTheme}>Trocar Tema</button>
    </ThemeContext.Provider>
  );
}
```
</TabItem>
<TabItem label="3. ThemedButton.jsx (Consumidor)">
```jsx
import { useContext } from 'react';
import { ThemeContext } from './theme-context';

function ThemedButton() {
  // 3. Usamos o Hook useContext para ler o valor do contexto.
  const { theme } = useContext(ThemeContext);

  const style = {
    background: theme === 'dark' ? '#333' : '#FFF',
    color: theme === 'dark' ? '#FFF' : '#333',
    border: '1px solid',
    padding: '8px',
  };

  return <button style={style}>Bot√£o com Tema</button>;
}

// Imagine que ThemedButton est√° dentro de um componente Toolbar,
// que est√° dentro de App. Ele acessa o tema sem prop drilling!
```
</TabItem>
</Tabs>

## Aviso de Performance

O `useContext` √© uma ferramenta poderosa, mas tem uma desvantagem importante: quando o valor de um `Provider` muda, **todos os componentes que consomem esse contexto com `useContext` ser√£o re-renderizados**, mesmo que a parte espec√≠fica do valor que eles usam n√£o tenha mudado.

<Aside type="caution" title="Use com Modera√ß√£o">
O Context API √© ideal para dados de **baixa frequ√™ncia de atualiza√ß√£o**, como informa√ß√µes de autentica√ß√£o, tema ou idioma. Para estados complexos e que mudam com frequ√™ncia, bibliotecas de gerenciamento de estado dedicadas (como Zustand ou Redux) podem oferecer um controle de performance mais granular.
</Aside>

Uma forma de mitigar isso √© dividir contextos grandes em contextos menores e mais espec√≠ficos. Assim, os componentes s√≥ se inscrevem nas atualiza√ß√µes que realmente lhes interessam.

---

Com o `useContext`, resolvemos o compartilhamento de dados. Mas e a performance? Vamos agora explorar os Hooks de otimiza√ß√£o: **`useMemo` e `useCallback`**.
