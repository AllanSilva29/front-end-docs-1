---
title: 'useMemo e useCallback: Otimização'
description: 'Aprenda a usar os Hooks useMemo e useCallback para otimizar a performance de seus componentes React, evitando cálculos caros e re-renderizações desnecessárias.'
---

import { Aside, Card, CardGrid } from '@astrojs/starlight/components';

À medida que suas aplicações crescem, você pode encontrar gargalos de performance. O React é rápido por padrão, mas às vezes precisamos dar uma "ajuda" para que ele evite trabalho desnecessário. É aí que entram os Hooks de otimização: `useMemo` e `useCallback`.

Ambos os Hooks são baseados no conceito de **memoização**: uma técnica de otimização que armazena o resultado de uma operação cara e o reutiliza quando os mesmos inputs ocorrem novamente.

<Aside type="caution" title="Não Otimize Prematuramente">
Esses Hooks devem ser usados com um propósito. Otimizações têm um custo (maior complexidade de código e consumo de memória). A regra de ouro é: **meça primeiro** (usando o React DevTools Profiler) e só então aplique a otimização onde for realmente necessário.
</Aside>

## A Diferença Fundamental

Apesar de serem parecidos, eles memoizam coisas diferentes:

-   `useMemo` memoiza o **valor de retorno** de uma função.
-   `useCallback` memoiza a **própria definição da função**.

## `useMemo`: Memoizando Valores

Use o `useMemo` quando você tiver um cálculo computacionalmente caro dentro do seu componente, e você não quer que ele seja re-executado a cada renderização.

A função que você passa para o `useMemo` só será re-executada se uma das dependências em seu array de dependências mudar.

**Cenário Ideal:** Filtrar ou ordenar uma lista muito grande de dados.

```jsx
import { useMemo, useState } from 'react';

function ProductList({ allProducts, searchTerm }) {
  // Este cálculo pode ser muito lento se 'allProducts' for grande.
  const visibleProducts = useMemo(() => {
    console.log('Filtrando a lista de produtos... (Operação cara!)');
    return allProducts.filter(p => p.name.includes(searchTerm));
  }, [allProducts, searchTerm]); // Só re-executa se allProducts ou searchTerm mudar.

  return (
    <ul>
      {visibleProducts.map(product => (
        <li key={product.id}>{product.name}</li>
      ))}
    </ul>
  );
}
```
Sem `useMemo`, a filtragem ocorreria a cada renderização do `ProductList`, mesmo que apenas uma `prop` não relacionada tivesse mudado.

## `useCallback`: Memoizando Funções

JavaScript tem uma particularidade: funções definidas dentro de um componente são **recriadas a cada renderização**. Para o React, `() => {}` em uma renderização é diferente de `() => {}` na próxima.

Isso se torna um problema quando você passa uma função como `prop` para um componente filho que está otimizado com `React.memo`.

<Card title="React.memo" icon="star">
`React.memo` é um Higher-Order Component que impede que um componente seja re-renderizado se suas `props` não mudaram. Ele faz uma comparação superficial das `props`.
</Card>

Se a função `prop` é sempre "nova", a otimização do `React.memo` é inútil. O `useCallback` resolve isso. Ele retorna uma versão memoizada da sua função que só muda se uma de suas dependências mudar.

**Cenário Ideal:** Passar uma função de callback para um componente filho memoizado.

```jsx
import { useCallback, useState } from 'react';
import React from 'react';

// Um componente filho memoizado que só re-renderiza se suas props mudarem.
const MyButton = React.memo(({ onClick }) => {
  console.log('Botão re-renderizou!');
  return <button onClick={onClick}>Clique aqui</button>;
});

function ParentComponent() {
  const [count, setCount] = useState(0);

  // Sem useCallback, esta função seria recriada a cada renderização do Parent,
  // fazendo com que MyButton re-renderizasse desnecessariamente.
  const handleClick = useCallback(() => {
    console.log('Botão clicado!');
    // A função depende de 'count' para ser recriada? Não neste caso.
    // Se precisasse de 'count', adicionaríamos a dependência: [count]
  }, []); // O array vazio garante que a função NUNCA seja recriada.

  return (
    <div>
      <p>Contador: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>Incrementar</button>
      <MyButton onClick={handleClick} />
    </div>
  );
}
```

Em resumo:
- Use `useMemo` para evitar **cálculos caros**.
- Use `useCallback` para evitar **re-renderizações de componentes filhos**, passando referências de funções estáveis.

---

Agora que sabemos como otimizar nossos componentes, vamos explorar um Hook para situações onde precisamos "escapar" do fluxo declarativo do React: o **`useRef`**.
