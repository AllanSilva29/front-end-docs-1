---
title: 'useRef: Acessando o DOM e Mais'
description: 'Descubra como usar o Hook useRef para acessar diretamente nós do DOM e para manter valores mutáveis que não disparam re-renderizações.'
---

import { Aside, Card, CardGrid } from '@astrojs/starlight/components';

O `useRef` é um Hook que funciona como uma "caixa" para guardar um valor mutável que **não dispara uma nova renderização** quando é alterado. Ele retorna um objeto com uma única propriedade: `current`.

```jsx
const minhaRef = useRef(valorInicial);

// Para ler o valor: minhaRef.current
// Para mudar o valor: minhaRef.current = novoValor;
```

Diferente do `useState`, alterar `minhaRef.current` não informa ao React para atualizar a UI. Isso torna o `useRef` perfeito para dois casos de uso principais.

## Caso de Uso 1: Acessando Nós do DOM

Este é o uso mais comum do `useRef`. Às vezes, precisamos interagir diretamente com um elemento do DOM para fazer algo que o fluxo declarativo do React não consegue lidar, como:

-   Focar um campo de input programaticamente.
-   Disparar uma animação imperativa.
-   Medir o tamanho ou a posição de um elemento.

Para isso, você passa a `ref` para o atributo `ref` de um elemento JSX.

**Exemplo: Focar um input ao clicar em um botão.**

```jsx
import { useRef } from 'react';

function FocusInput() {
  // 1. Cria a ref. O valor inicial é null.
  const inputRef = useRef(null);

  const handleClick = () => {
    // 3. Acessa o nó do DOM através de .current e chama seu método .focus()
    inputRef.current.focus();
  };

  return (
    <>
      {/* 2. Anexa a ref ao elemento input do DOM. */}
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>
        Focar no Input
      </button>
    </>
  );
}
```
<Aside type="caution" title="Use com Cautela">
Acessar o DOM diretamente deve ser sua última opção. Sempre prefira a abordagem declarativa com `props` e `state` quando possível. Refs são a "válvula de escape", não a regra.
</Aside>

## Caso de Uso 2: Guardando Valores Entre Renderizações

Como uma `ref` persiste entre as renderizações e não causa atualizações na UI, ela é perfeita para guardar valores que você precisa "lembrar" mas que não afetam diretamente a aparência do componente.

Pense nela como uma "variável de instância" de um componente de função.

**Exemplo: Guardar o ID de um `setInterval`.**

```jsx
import { useState, useRef, useEffect } from 'react';

function Timer() {
  const [seconds, setSeconds] = useState(0);
  // Usamos a ref para guardar o ID do intervalo.
  // Não usamos state porque mudar o ID não deve re-renderizar.
  const intervalIdRef = useRef(null);

  const handleStart = () => {
    // Evita criar múltiplos intervalos se já houver um rodando.
    if (intervalIdRef.current) return;

    intervalIdRef.current = setInterval(() => {
      setSeconds(prevSeconds => prevSeconds + 1);
    }, 1000);
  };

  const handleStop = () => {
    clearInterval(intervalIdRef.current);
    intervalIdRef.current = null;
  };

  // Limpa o intervalo se o componente for desmontado.
  useEffect(() => {
    return () => clearInterval(intervalIdRef.current);
  }, []);

  return (
    <div>
      <p>Segundos: {seconds}</p>
      <button onClick={handleStart}>Iniciar</button>
      <button onClick={handleStop}>Parar</button>
    </div>
  );
}
```

## Encaminhando Refs com `forwardRef`

Por padrão, você não pode passar uma `ref` para um dos seus próprios componentes (`<MyInput ref={myRef} />`). Se você precisa que o componente pai tenha acesso a um nó do DOM dentro de um componente filho, você deve "envelopar" o componente filho com `React.forwardRef`.

`forwardRef` permite que seu componente receba uma `ref` e a "encaminhe" para um elemento DOM interno.

```jsx
import React, { useRef, forwardRef } from 'react';

// 1. O componente filho é envolvido em forwardRef.
//    Ele agora recebe 'ref' como segundo argumento.
const FancyInput = forwardRef((props, ref) => {
  return <input ref={ref} className="fancy" {...props} />;
});

// 2. O componente pai agora pode usar a ref no FancyInput.
function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <FancyInput ref={inputRef} />
      <button onClick={handleClick}>Focar</button>
    </>
  );
}
```
Isso é essencial ao construir bibliotecas de componentes reutilizáveis.

---

Agora que conhecemos os Hooks mais importantes, precisamos entender as regras que governam seu uso. Vamos explorar **As Regras dos Hooks**.
