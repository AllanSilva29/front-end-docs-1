---
title: 'As Regras dos Hooks'
description: 'Entenda as duas regras essenciais que governam o uso de Hooks em React e por que elas são cruciais para o funcionamento correto da sua aplicação.'
---

import { Aside, Card, CardGrid } from '@astrojs/starlight/components';

Os Hooks são poderosos, mas esse poder vem com algumas regras simples que você precisa seguir para que eles funcionem corretamente. Essas regras não são apenas sugestões ou convenções; elas são essenciais para que o React possa gerenciar o estado e os efeitos dos seus componentes de forma previsível.

Felizmente, existem apenas duas regras para lembrar.

## Regra 1: Chame Hooks Apenas no Nível Superior

**Não chame Hooks dentro de laços (`for`, `while`), condicionais (`if`) ou funções aninhadas.**

Sempre chame os Hooks no nível superior do seu componente de função, antes de qualquer `return`.

<div style="padding: 0 100px">
  <CardGrid>
    <Card title="❌ Incorreto">
      ```jsx
      function MyComponent({ showEffect }) {
        if (showEffect) {
          // ERRADO: Hook chamado dentro de um condicional.
          useEffect(() => {
            // ...
          });
        }
        
        const [name, setName] = useState(''); // OK
        // ...
      }
      ```
    </Card>
      <br/>
    <Card title="✅ Correto">
      ```jsx
      function MyComponent({ showEffect }) {
        const [name, setName] = useState(''); // OK

        useEffect(() => {
          // Coloque o condicional *dentro* do Hook.
          if (showEffect) {
            // ...
          }
        }, [showEffect]); // OK

        // ...
      }
      ```
    </Card>
  </CardGrid>
</div>

## Regra 2: Chame Hooks Apenas de Componentes de Função React

**Não chame Hooks de funções JavaScript comuns.**

Você só pode chamar Hooks a partir de duas fontes:

1.  De **Componentes de Função** React.
2.  De **Custom Hooks** (que, por sua vez, só podem ser chamados de componentes ou outros Custom Hooks).

<div style="padding: 0 100px">
  <CardGrid>
    <Card title="❌ Incorreto">
      ```jsx
      // Uma função JavaScript comum, não um componente.
      function updateTitle(title) {
        // ERRADO: Hooks não podem ser chamados aqui.
        useEffect(() => {
          document.title = title;
        }, [title]);
      }
      ```
    </Card>
      <br/>
    <Card title="✅ Correto">
      ```jsx
      // Um componente de função React.
      function TitleUpdater({ title }) {
        // OK: Hook chamado dentro de um componente.
        useEffect(() => {
          document.title = title;
        }, [title]);
        
        return <h1>{title}</h1>;
      }
      ```
    </Card>
  </CardGrid>
</div>

## Mas... Por Que Essas Regras Existem?

A razão por trás dessas regras é surpreendentemente simples: **O React depende da ordem em que os Hooks são chamados para associar o estado e os efeitos a um componente.**

Para cada componente, o React mantém uma "lista" interna de células de memória para cada Hook.

-   Na primeira renderização, o `useState` na primeira linha obtém a primeira célula de memória. O `useEffect` na segunda linha obtém a segunda, e assim por diante.
-   Em cada renderização subsequente, o React espera que os Hooks sejam chamados **exatamente na mesma ordem**. Assim, ele pode fornecer o estado correto para cada chamada de `useState` e gerenciar os efeitos corretamente.

Se você colocar um Hook dentro de um `if`, a ordem de chamada pode mudar entre as renderizações. Em uma renderização, o `if` pode ser `true` e o Hook é chamado. Na outra, pode ser `false` e o Hook é pulado. Isso bagunçaria toda a sequência de Hooks, e o React perderia o controle de qual estado pertence a qual chamada, levando a bugs imprevisíveis.

<Aside type="tip" title="Use o Linter!">
Felizmente, você não precisa se preocupar em memorizar e policiar essas regras o tempo todo. A equipe do React fornece um plugin de ESLint chamado `eslint-plugin-react-hooks` que detecta violações dessas regras automaticamente no seu editor de código. Se você usou o `Create React App` ou o `Next.js`, ele já vem configurado por padrão.
</Aside>

---

Seguindo essas regras, você garante que seus componentes sejam robustos e previsíveis. Agora que dominamos as regras, vamos ver como podemos criar nossa própria mágica com **Custom Hooks**.
