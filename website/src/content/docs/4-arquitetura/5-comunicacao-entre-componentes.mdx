---
title: 'Comunica√ß√£o entre Componentes'
description: 'Um guia consolidado sobre os principais padr√µes de comunica√ß√£o entre componentes em uma aplica√ß√£o React, do mais simples ao mais avan√ßado.'
---

import { Aside, Card, CardGrid } from '@astrojs/starlight/components';

Uma aplica√ß√£o React √© uma √°rvore de componentes que precisam trocar informa√ß√µes para funcionar. Entender os diferentes padr√µes de comunica√ß√£o √© fundamental para arquitetar um fluxo de dados limpo e previs√≠vel.

O princ√≠pio central que governa essa comunica√ß√£o √© o **Fluxo de Dados Unidirecional** (ou "top-down"). Os dados fluem de componentes pais para componentes filhos, o que torna a aplica√ß√£o mais f√°cil de depurar e entender.

Vamos revisar os quatro principais padr√µes de comunica√ß√£o.

### Padr√£o 1: Pai para Filho (via `props`)

Este √© o padr√£o mais b√°sico e comum. Um componente pai passa dados para um componente filho atrav√©s de `props`. O filho recebe esses dados e os utiliza para renderizar sua UI.

<Card title="‚¨áÔ∏è Como funciona">
```jsx
function Parent() {
  const userName = "Alice";
  return <ChildComponent name={userName} />;
}

function ChildComponent(props) {
  // O filho recebe e usa o dado
  return <h1>Bem-vindo(a), {props.name}!</h1>;
}
```
</Card>

### Padr√£o 2: Filho para Pai (via Callbacks)

Mas e se um filho precisar comunicar algo de volta para o pai, como um clique de bot√£o ou um valor de input? Como o fluxo √© unidirecional, o filho n√£o pode modificar o pai diretamente.

A solu√ß√£o √© o pai passar uma **fun√ß√£o de callback** para o filho via `props`. O filho, ent√£o, chama essa fun√ß√£o quando um evento ocorre, passando dados como argumento se necess√°rio.

<Card title="‚¨ÜÔ∏è Como funciona">
```jsx
function Parent() {
  const [inputValue, setInputValue] = useState('');

  // 1. O pai define a fun√ß√£o de callback.
  const handleInputChange = (newValue) => {
    setInputValue(newValue);
  };

  return (
    <div>
      <p>O valor digitado √©: {inputValue}</p>
      {/* 2. A fun√ß√£o √© passada como prop para o filho. */}
      <ChildInput onChange={handleInputChange} />
    </div>
  );
}

function ChildInput(props) {
  // 3. O filho chama a fun√ß√£o recebida quando o evento ocorre.
  return (
    <input
      type="text"
      onChange={(e) => props.onChange(e.target.value)}
    />
  );
}
```
</Card>

### Padr√£o 3: Entre Componentes Irm√£os

Dois componentes irm√£os n√£o podem se comunicar diretamente. Se o `ComponenteA` precisa afetar o `ComponenteB`, eles precisam de um intermedi√°rio. A solu√ß√£o padr√£o do React para isso √© **"Lifting State Up" (Elevar o Estado)**.

A ideia √© mover o estado compartilhado para o **ancestral comum mais pr√≥ximo** dos componentes irm√£os. Esse ancestral ent√£o gerencia o estado e o distribui para os filhos via `props` (Padr√£o 1) e recebe atualiza√ß√µes via callbacks (Padr√£o 2).

<Card title="üë• Como funciona">
```jsx
// O ancestral comum (App) gerencia o estado.
function App() {
  const [count, setCount] = useState(0);

  return (
    <div>
      {/* Ele passa o estado e o callback para ambos os irm√£os. */}
      <Display count={count} />
      <Button onClick={() => setCount(count + 1)} />
    </div>
  );
}

function Display({ count }) {
  return <p>Contagem: {count}</p>;
}

function Button({ onClick }) {
  return <button onClick={onClick}>Incrementar</button>;
}
```
</Card>

### Padr√£o 4: Entre Componentes Distantes

Quando o "Lifting State Up" se torna impratic√°vel porque os componentes est√£o muito distantes na √°rvore (levando ao "prop drilling"), recorremos a solu√ß√µes de estado global.

<Card title="üå≥ Como funciona">
-   **`useContext`:** A solu√ß√£o nativa do React. Voc√™ cria um `Provider` no topo da √°rvore e qualquer componente filho pode "consumir" os dados diretamente, sem pass√°-los por `props`. Ideal para dados de baixa frequ√™ncia de atualiza√ß√£o.
-   **Bibliotecas de Estado Global (Zustand, Redux):** Para estados complexos e de alta frequ√™ncia, essas bibliotecas oferecem um "store" desacoplado da √°rvore de componentes. Qualquer componente pode se inscrever e reagir a mudan√ßas no estado de forma otimizada.
</Card>

## Fluxograma de Decis√£o

<Aside type="note" title="Qual padr√£o usar?">

1.  Os componentes t√™m uma rela√ß√£o pai-filho?
    -   **Sim:** Use `props` e callbacks.
2.  Eles s√£o irm√£os?
    -   **Sim:** Use "Lifting State Up".
3.  Eles s√£o distantes na √°rvore?
    -   **Sim:** O estado muda com frequ√™ncia?
        -   **N√£o:** Use `useContext`.
        -   **Sim:** Use uma biblioteca de estado global.
</Aside>




